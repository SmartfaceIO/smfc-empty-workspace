"use strict";

exports.__esModule = true;
exports.default = void 0;

var StyleContext = _interopRequireWildcard(require("../styling/StyleContext"));

var _styler = _interopRequireDefault(require("@smartface/styler/lib/styler"));

var _commandsManager = _interopRequireDefault(require("@smartface/styler/lib/commandsManager"));

var _merge = _interopRequireDefault(require("@smartface/styler/lib/utils/merge"));

var _sfCorePropFactory = _interopRequireDefault(require("./sfCorePropFactory"));

var _screen = _interopRequireDefault(require("sf-core/device/screen"));

var _system = _interopRequireDefault(require("sf-core/device/system"));

var _isTablet = _interopRequireDefault(require("../core/isTablet"));

var _Stylable = _interopRequireDefault(require("../styling/Stylable"));

var _hooks = _interopRequireDefault(require("../core/hooks"));

var _constants = _interopRequireDefault(require("../core/constants"));

var _fromSFComponent = _interopRequireWildcard(require("./fromSFComponent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

var orientationState = "ended";

_commandsManager.default.addRuntimeCommandFactory(function pageContextRuntimeCommandFactory(type, error) {
  switch (type) {
    case '+Device':
      return function deviceRule(opts) {
        var Device = {
          screen: {
            width: _screen.default.width,
            height: _screen.default.height
          },
          os: _system.default.OS,
          osVersion: _system.default.OSVersion,
          type: _isTablet.default ? "tablet" : "phone",
          orientation: _screen.default.width > _screen.default.height ? "landscape" : "portrait",
          language: _system.default.language
        };
        opts = (0, _merge.default)(opts);
        let isOK = false;

        try {
          isOK = eval(opts.args);
        } catch (e) {
          error && error(e);
          return {};
        }

        return isOK ? opts.value : {};
      };
  }
});
/**
 * Creates new page context boundry
 * 
 * @param {object} component - Root component of the context
 * @param {string} name - Root component ID
 * @param {function} reducers - Reducers function
 */


function createPageContext(component, name, reducers = null) {
  var styleContext = (0, _fromSFComponent.default)(component, name, //context hooks
  function (hook) {
    switch (hook) {
      case 'beforeStyleDiffAssign':
        return function beforeStyleDiffAssign(styles) {
          return (0, _sfCorePropFactory.default)(styles);
        };

      case 'reduceDiffStyleHook':
        return function reduceDiffStyleHook(oldStyles, newStyles) {
          function isEqual(oldStyle, newStyle) {
            if (oldStyle === undefined) {
              return false;
            }

            var keys1 = Object.keys(oldStyle);
            var keys2 = Object.keys(newStyle);

            if (keys1.length !== keys2.length) {
              return false;
            }

            let res = keys2.some(function (key) {
              return oldStyle[key] !== newStyle[key];
            });
            return !res;
          }

          return function diffStylingReducer(acc, key) {
            // align is readolnly issue on Android
            if (key === 'align') {
              acc[key] = undefined;
              return acc;
            } else if (key === "layout") {
              var diffReducer = reduceDiffStyleHook(oldStyles[key] || {}, newStyles[key] || {});
              Object.keys(newStyles[key] || {}).reduce(diffReducer, acc[key] = {});
            } else if (key == "flexProps" && newStyles[key]) {
              Object.keys(newStyles[key]).forEach(function (name) {
                if (oldStyles[key] === undefined || newStyles[key][name] !== oldStyles[key][name]) {
                  acc[name] = newStyles[key][name];

                  if (newStyles[key][name] === null) {
                    acc[name] = NaN; // fixes flexgrow NaN value bug

                    if (name === "flexGrow") {
                      acc[name] = 0;
                    }
                  } else {
                    acc[name] = newStyles[key][name];
                  }
                }
              });
            } else if (newStyles[key] !== null && newStyles[key] instanceof Object) {
              if (Object.keys(newStyles[key]).length > 0 && !isEqual(oldStyles[key] || {}, newStyles[key])) {
                acc[key] = (0, _merge.default)(oldStyles[key], newStyles[key]);
              }
            } else if (oldStyles[key] !== newStyles[key]) {
              acc[key] = newStyles[key];
            }

            if (acc[key] === null) {
              acc[key] = NaN;
            }

            return acc;
          };
        };
    }

    return undefined;
  });

  const _contextReducer = reducers ? function (context, action, target, state) {
    const newState = contextReducer(context, action, target, state);
    return reducers(context, action, target, newState || state);
  } : contextReducer; // creates an initial styling for the context
  // styleContext(styling, _contextReducer);


  return function setStyle(styling) {
    try {
      // const styling = styler(newStyles);
      // injects a new styling to the context
      styleContext(styling, _contextReducer);
    } catch (e) {
      throw e;
    }
  };
}

function contextReducer(context, action, target, state) {
  const newState = Object.assign({}, state);

  switch (action.type) {
    case "updateUserStyle":
      context.find(target, {
        updateUserStyle: () => {
          throw new TypeError(`Target ${target} component cannot be found.`);
        }
      }).updateUserStyle(action.userStyle);
      return newState;

    case "changeUserStyle":
      context.find(target, {
        setUserStyle: () => {
          throw new TypeError(`Target ${target} component cannot be found.`);
        }
      }).setUserStyle(action.userStyle);
      return newState;

    case "updatePageSafeArea":
      context.find(target, {
        setSafeArea: () => {
          throw new TypeError(`Target ${target} component cannot be found.`);
        }
      }).setSafeArea(Object.assign({}, action.safeArea));
      return newState;

    case "invalidate":
      context.map(function (actor) {
        actor.setDirty(true);
      });
      return newState;

    case 'addChild':
      const rootName = target + "_" + action.name;
      const ctree = (0, _fromSFComponent.createActorTreeFromSFComponent)(action.component, action.name, target, action.defaultClassNames);
      /*if(action.classNames && typeof action.classNames !== 'string' && !Array.isArray(action.classNames)){
      	throw new Error(action.classNames+" classNames must be String or Array");
      }*/

      ctree[target + "_" + action.name] && action.classNames && ctree[rootName].pushClassNames(action.classNames);
      action.userStyle && ctree[rootName].setUserStyle(action.userStyle);
      context.addTree(ctree);
      return newState;

    case 'removeChild':
      context.remove(target);
      return newState;

    case 'removeChildren':
      context.removeChildren(target);
      return newState;

    case 'pushClassNames':
      if (!action.classNames) throw new Error("Classnames must not be null or undefined");
      context.find(target).pushClassNames(action.classNames);
      return newState;

    case 'removeClassName':
      context.find(target).removeClassName(action.className);
      return newState;

    case "orientationStarted":
      context.map(function (actor) {
        actor.setDirty(true);
      });
      orientationState = "started";
      return newState;

    case "orientationEnded":
      context.map(function (actor) {
        actor.setDirty(true);
      });
      orientationState = "ended";
      return newState;

    case "updateComponent":
      let stylable = context.find(target);
      stylable.updateComponent(action.component);
      stylable.applyStyles(true);
      return newState;
  }

  return state;
}

var _default = createPageContext;
exports.default = _default;
module.exports = exports["default"];