"use strict";

exports.__esModule = true;
exports.createStyleContext = createStyleContext;

var _constants = require("../core/constants");

var _Context = _interopRequireDefault(require("../core/Context"));

var _merge = _interopRequireDefault(require("@smartface/styler/lib/utils/merge"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Style Context. Returns context composer
 * 
 * @param {Array.<Object>} actors - Actors List
 * @param {function} hookMaybe - Hooks factory
 * @returns {function} - Context Composer Function
 */
function createStyleContext(actors, hookMaybe, updateContextTree) {
  var context;
  /**
   * Context builder.
   * 
   * @param {function) styling - Styling function from styler.
   * @param {function} reducer - Reducer function to run actions
   */

  return function recomposeStylingContext(styling, reducer) {
    // context reducer
    function contextUpdater(context, action, target, state) {
      var newState = Object.assign({}, state);

      switch (action.type) {
        case 'updateContext':
          updateContextTree(context.actors);
          break;

        case 'forceComponentUpdate':
          const actor = context.find(target + "_" + action.name, null);
          actor && actor.reset();
          break;

        /*case 'addContextChild':
          Array.isArray(action.newComp)
            ? action.newComp.forEach((component) => {
                context.add(component);
              })
            : context.add(action.newComp);
        break;*/

        case 'removeContextChild':
          context.remove(action.name);
          break;
      }

      if (target && action.type !== _constants.INIT_CONTEXT_ACTION_TYPE) {
        newState = reducer(context, action, target, state); // state is not changed

        if (newState === state) {
          // return current state instance
          return state;
        }
      }

      context.map(function invalidateStyles(actor, name) {
        if (actor.isDirty === true || action.type === _constants.INIT_CONTEXT_ACTION_TYPE) {
          let className = actor.getClassName();
          const beforeHook = hookMaybe("beforeAssignComponentStyles", null);
          beforeHook && (className = beforeHook(name, className));

          try {
            if (className) {
              const styles = styling(className)();
              actor.setStyles(styles);
            }

            actor.applyStyles();
          } catch (e) {
            e.message = `While actor's style [${name}] is set. ${e.message}`;
            throw e;
          }
        }
      });
      latestState = newState;
      return newState;
    }

    var latestState = context ? context.getState() : {}; //creates new context

    context = new _Context.default(context && context.reduce((acc, actor, name) => {
      acc[name] = actor;
      return acc;
    }, {}) || actors, contextUpdater, latestState, hookMaybe);
    return context;
  };
}