"use strict";

exports.__esModule = true;
exports.createThemeContextBound = createThemeContextBound;

var _constants = require("../core/constants");

var _Context = _interopRequireDefault(require("../core/Context"));

var _merge = _interopRequireDefault(require("@smartface/styler/lib/utils/merge"));

var _buildStyles = _interopRequireDefault(require("@smartface/styler/lib/buildStyles"));

var _styler = _interopRequireDefault(require("@smartface/styler/lib/styler"));

var _Actor = _interopRequireDefault(require("../core/Actor"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Theme {
  constructor({
    name,
    rawStyles,
    isDefault = false
  }) {
    _defineProperty(this, "isDefault", () => {
      return this._isDefault;
    });

    _defineProperty(this, "setDefault", value => {
      this._isDefault = value;
      value && !this.bundle && this.build();
      return value;
    });

    _defineProperty(this, "build", () => {
      this.bundle = (0, _buildStyles.default)(this.rawStyles);
    });

    _defineProperty(this, "asStyler", () => {
      return (0, _styler.default)(this.bundle);
    });

    this.name = name;
    this.rawStyles = rawStyles;
    this.setDefault(isDefault);
  }

}

class Themeable extends _Actor.default {
  constructor(pageContext, name) {
    super(pageContext, name);
    this.pageContext = pageContext;
  }

  changeStyling(styling) {
    this.pageContext(styling);
    this.isDirty = true;
  }

}
/**
 * Theme Context. Returns context bound
 * 
 * @param {Array.<{name:string, rawStyles:Object, isDefault:boolean}>} themes - h List
 * 
 * @returns {function} - Context dispatcher
 */


function createThemeContextBound(themes) {
  const themesCollection = themes.map(theme => new Theme(theme));

  function themesReducer(context, action, target, state) {
    var newState = Object.assign({}, state);

    switch (action.type) {
      case 'addThemeable':
        const actor = new Themeable(action.pageContext, action.name);
        context.add(actor, action.name);
        const theme = themesCollection.find(theme => theme.isDefault());
        actor.changeStyling(theme.asStyler());
        return newState;

      case 'removeThemeable':
        context.remove(action.name);
        return newState;

      case 'changeTheme':
        themesCollection.forEach(theme => {
          if (theme.name === action.theme) {
            theme.setDefault(true);
            context.map(actor => {
              actor.changeStyling(theme.asStyler());
            });
          } else {
            theme.setDefault(false);
          }
        });
        return _objectSpread({}, state, {
          theme: action.theme
        });
    }

    return state;
  }

  const themeContext = new _Context.default( // creates themes actors
  {}, themesReducer, // initial state
  {
    theme: themesCollection.find(theme => theme.isDefault === true)
  });
  return function (pageContext, name) {
    pageContext === null ? themeContext.dispose() : pageContext !== undefined && themeContext.dispatch({
      type: "addThemeable",
      name: name,
      pageContext: pageContext
    });
    return function themeContextDispatch(action) {
      if (action === null) {
        name && themeContext.dispatch({
          type: "removeThemeable",
          name: name
        });
      } else {
        themeContext.dispatch(action);
      }
    };
  };
}